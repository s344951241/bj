1.垃圾回收机制：垃圾回收器，检测到进程托管堆满了以后，调用垃圾回收器检查对象的引用，删除没有引用的对象

2. 值类型存储在堆栈中，引用类型存储在托管堆上

3. 装箱是将值类型转换为引用类型,拆箱是将引用类型转换为值类型 

4. class 是引用类型所有的类都最终继承自System.Object类，structs是值类型所有的结构都继承自System.ValueType类
Struct有性能优势，Class有面向对象的扩展优势

5. uint i = 1u,long i = 1L,float f = 0.1f ulong i = 2uL decimal d = 1.0M

6. 字符串string是引用类型，string a = “1”赋值都会创建堆，而且string b = a是重新创建堆内存的

7. @""后面的字符串都不会解释为转译字符

8. switch case 中可加入goto case

9. 字符串获取枚举=>(EnumClass)Enum.Parse(typeof(EnumClass),"name",true)

10. ref：函数传递参数时使值传递变为引用传递

11. out:作为引用传递同时可以不赋初值

12. readonly可以在构造函数中赋值，const只能定义是赋初值

13. WeakReference弱引用,垃圾回收器运行时就会回收 WeakReference a = new WeakReference(new A()).Target

14. partial 部分类，把一个类拆开几个部分定义

15. new 隐藏方法：在向上转型后，重写基类方法的调用的是派生类的方法，而隐藏基类调用的是基类的方法

16. sealed 密封类和密封方法

17. 泛型不能赋空值null。有值类型，应使用default(T)

18. 泛型约束：ClassB<T> where T:ClassA    T继承ClassA
                        where T:new()     T必须有默认构造函数
                        where T:struct    T为值类型
                        where T:class     T为引用类型

19. 泛型的继承必须指定基类的泛型类型

20. 泛型类的静态成员只能在类的一个实例中共享

21. 协变：方法参数类型（父参数传子类型）
    抗变：方法返回类型（返回子类型服给父类型）
    【InterfaceA<out T>协变           InterfaceA<in T>抗变】（用在泛型接口中）

22. 可空值类型：  int? x  = null   ??用于空合并

23. 数组是引用类型，实现Array接口

24. yeild使用 与enumerator和foreach相关

25. Tuple元组

26. sizeof 确定栈中值类型需要的长度
    typeof 返回表示特定类型的System.Type对象

27. Object.ReferenceEquals(a,b) 是否引用一个实例

28. 委托 Action<in T>   不带返回值
         Funtion<in T,out TResult>   带返回值

29. 多播委托迭代方法列表，有一个方法抛出异常，委托迭代就会停止

30. 事件：继承自EventArgs的参数类
          event EventHandler<EventArgs> 定义事件列表
          外部赋值，内部执行
    弱事件： WeakEventManager

31. StringBuilder 高效的替换，追加，删除字符但要指定分配多少内存（多次）
        Length 指定字符串的实际长度
        Capacity 指定字符串在分配的内存中的最大长度
        MaxVale 最大容量

32.  ==它是比较的栈里面的值是否相等(值比较)
     Equals它比较的是堆里面的值是否相等(引用地址值比较)
     Object.ReferenceEquals(obj1,obj2)它是比较的是地址是否相等

33. ILookup<TKey,TValue> 一键对应多个值
    IReadOnlyCollection<T>
    IReadOnlyList<T>
    IReadOnlyDictionary<TKey,TValue>  只读类型

    ImmutableArray<T> 不变集合，add方法返回值为新集合，本身却没变

---------------------------------------------------------------------
class Person
{
    int id;
    string name;
    string info;
}

ILookup<string,Person> TheLookup;
List<Person> list;

list = new List<Person>{
    new Person{id=1,name="xx",info="0000"}
    new Person{id=2,name="ww",info="1111"}
    new Person{id=3,name="xx",info="2222"}
}

TheLookup = list.ToLookup(p=>p.name);
foreach(var group in TheLookup)
{
    foreach(var item in group)
    {

    }
}
----------------------------------------------------------------------
34. LinkedList<T> 双向列表

35. 有序字典 SortedList<TKey,TValue>     内存少
             SortedDictionary<TKey,TValue>    插入删除未排序的数据快

36. 集，包含不重复的集合  HashSet<T>
                          SortedSet<T>

37. 位数组，BitArray 可以重新设置大小   Or()  And()   Xor()
            BitVector32 结构基于栈，十六进制4位，的相关东西
                BitVector32 bits = new BitVector32(0x79abcdef)
                -->01111001101010111100110111101111

38. 线程安全的集合，用tryxxx方法添加元素，返回值判断是否成功
    ConcurrentQueue<T>
    ConcurrentStack<T>
    ConcurrentBag<T>
    ConcurrentDictionary<TKey,TValue>
    BlockingCollection<T>  添加或提取前，会阻塞线程并一直等待

39. 在遍历数据结构的时候，是不可以修改原数据结构的

40. StackOverflowException--分配给栈的内存区域已满
    EndOfStreamException--读到文件末尾抛出
    OverflowException--int类型强转


