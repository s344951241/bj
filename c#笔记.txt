1.垃圾回收机制：垃圾回收器，检测到进程托管堆满了以后，调用垃圾回收器检查对象的引用，删除没有引用的对象

2. 值类型存储在堆栈中，引用类型存储在托管堆上

3. 装箱是将值类型转换为引用类型,拆箱是将引用类型转换为值类型 

4. class 是引用类型所有的类都最终继承自System.Object类，structs是值类型所有的结构都继承自System.ValueType类
Struct有性能优势，Class有面向对象的扩展优势

5. uint i = 1u,long i = 1L,float f = 0.1f ulong i = 2uL decimal d = 1.0M

6. 字符串string是引用类型，string a = “1”赋值都会创建堆，而且string b = a是重新创建堆内存的

7. @""后面的字符串都不会解释为转译字符

8. switch case 中可加入goto case

9. 字符串获取枚举=>(EnumClass)Enum.Parse(typeof(EnumClass),"name",true)

10. ref：函数传递参数时使值传递变为引用传递

11. out:作为引用传递同时可以不赋初值

12. readonly可以在构造函数中赋值，const只能定义是赋初值

13. WeakReference弱引用,垃圾回收器运行时就会回收 WeakReference a = new WeakReference(new A()).Target

14. partial 部分类，把一个类拆开几个部分定义

15. new 隐藏方法：在向上转型后，重写基类方法的调用的是派生类的方法，而隐藏基类调用的是基类的方法

16. sealed 密封类和密封方法

17. 泛型不能赋空值null。有值类型，应使用default(T)

18. 泛型约束：ClassB<T> where T:ClassA    T继承ClassA
                        where T:new()     T必须有默认构造函数
                        where T:struct    T为值类型
                        where T:class     T为引用类型

19. 泛型的继承必须指定基类的泛型类型

20. 泛型类的静态成员只能在类的一个实例中共享

21. 协变：方法参数类型（父参数传子类型）
    抗变：方法返回类型（返回子类型服给父类型）
    【InterfaceA<out T>协变           InterfaceA<in T>抗变】（用在泛型接口中）

22. 可空值类型：  int? x  = null   ??用于空合并

23. 数组是引用类型，实现Array接口

24. yeild使用 与enumerator和foreach相关

25. Tuple元组

26. sizeof 确定栈中值类型需要的长度
    typeof 返回表示特定类型的System.Type对象

27. ReferenceEquals(a,b) 是否引用一个实例
